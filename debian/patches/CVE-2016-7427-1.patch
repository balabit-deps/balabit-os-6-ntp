Backport of:


    TOPntp-stable1.3686.20.1 changes

NTP - Network Time Protocol
#### ChangeSet ####

2016-10-20 20:13:40+02:00, perlinger@ntp.org
  [Sec 3114] Broadcast Mode Replay Prevention DoS

#==== ChangeLog ====
#
#2016-10-20 20:13:40+02:00, perlinger@ntp.org +4 -0
#  [Sec 3114] Broadcast Mode Replay Prevention DoS
#--- 1.1834/ChangeLog	2016-06-02 11:39:59 +00:00
#+++ 1.1834.20.1/ChangeLog	2016-10-20 18:13:40 +00:00
#@@ -1,3 +1,7 @@
#+---
#+* [Sec 3114] Broadcast Mode Replay Prevention DoS
#+  - applied patches by Matthew Van Gundy. <perlinger@ntp.org>
#+
# ---
# (4.2.8p8) 2016/06/02 Released by Harlan Stenn <stenn@ntp.org>
#
#
#==== ntpd/ntp_proto.c ====
#
#2016-10-20 20:13:40+02:00, perlinger@ntp.org +39 -6
#  [Sec 3114] Broadcast Mode Replay Prevention DoS
#   - applied patches by Matthew Van Gundy, with some rework.
Index: ntp-4.2.8p4+dfsg/ntpd/ntp_proto.c
===================================================================
--- ntp-4.2.8p4+dfsg.orig/ntpd/ntp_proto.c	2017-06-28 11:41:56.448296802 -0400
+++ ntp-4.2.8p4+dfsg/ntpd/ntp_proto.c	2017-06-28 11:42:27.808679806 -0400
@@ -1253,9 +1253,32 @@ receive(
 				++bail;
 			}
 
-			tdiff = p_xmt;
-			L_SUB(&tdiff, &peer->bxmt);
-			if (tdiff.l_i < 0) {
+			/* Alert if time from the server is non-monotonic.
+			 *
+			 * Note this check will not trigger for
+			 * backsteps smaller than the poll interval.
+			 *
+			 * [Bug 3114] But watch for the the initial
+			 * state, when peer->bxmt is all-zero!
+			 *
+			 * Another gotcha to avoid here: After some
+			 * time, we must heed to time stamps, even when
+			 * they are in the past. Otherwise we would
+			 * never be able to catch up with a backstep of
+			 * our broadcast server until the server has
+			 * revored the backstep: The last bxmt now
+			 * survives a cleanout of the peer structure and
+			 * would create another form of DoS.
+			 */
+			if (L_ISZERO(&peer->bxmt)) {
+				tdiff.l_ui = tdiff.l_uf = 0;
+			} else {
+				tdiff = p_xmt;
+				L_SUB(&tdiff, &peer->bxmt);
+			}
+			if (tdiff.l_i < 0 &&
+			    (current_time - peer->timereceived) < (1u << (pkt->ppoll + 2)))
+			{
 				msyslog(LOG_INFO, "receive: broadcast packet from %s contains non-monotonic timestamp: %#010x.%08x -> %#010x.%08x",
 					stoa(&rbufp->recv_srcadr),
 					peer->bxmt.l_ui, peer->bxmt.l_uf,
@@ -1264,8 +1287,6 @@ receive(
 				++bail;
 			}
 
-			peer->bxmt = p_xmt;
-
 			if (bail) {
 				peer->timelastrec = current_time;
 				sys_declined++;
@@ -1466,6 +1487,13 @@ receive(
 	peer->xmt = p_xmt;
 
 	/*
+	 * Now that we know the packet is correctly authenticated,
+	 * update peer->bxmt if needed
+	 */
+	if (MODE_BROADCAST == hismode)
+		peer->bxmt = p_xmt;
+	
+	/*
 	 * Set the peer ppoll to the maximum of the packet ppoll and the
 	 * peer minpoll. If a kiss-o'-death, set the peer minpoll to
 	 * this maximum and advance the headway to give the sender some
@@ -2281,6 +2309,7 @@ peer_clear(
 	)
 {
 	u_char	u;
+	l_fp	bxmt = peer->bxmt;	/* bcast clients retain this! */
 
 #ifdef AUTOKEY
 	/*
@@ -2317,6 +2346,10 @@ peer_clear(
 	peer->flash = peer_unfit(peer);
 	peer->jitter = LOGTOD(sys_precision);
 
+	/* Don't throw away our broadcast replay protection */
+	if (peer->hmode == MODE_BCLIENT)
+		peer->bxmt = bxmt;
+
 	/*
 	 * If interleave mode, initialize the alternate origin switch.
 	 */
